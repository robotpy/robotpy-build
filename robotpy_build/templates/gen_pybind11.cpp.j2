{%- macro genbase(cls) -%}
{% if cls.inherits %}, {{ cls.inherits | join(', ', attribute='x_qualname')}}{% endif %}
{%- endmacro -%}

{%- macro fndef(fn) %}
{% if fn.static %}def_static{% else %}def{% endif %}
{% endmacro -%}

{%- macro fnptr(cls, fn) -%}
{% if fn.data.cpp_code %}
{{ fn.data.cpp_code }}
{% elif not fn.x_genlambda %}
&{% if cls %}{{ fn.namespace }}{{ cls.name }}::{% endif %}{{ fn.name }}
{% else %}
[]({{ fn.x_in_params | join(', ', attribute='x_decl') }}) {
          {% for stmt in fn.x_lambda_pre %}
          {{ stmt }};
          {% endfor %}
          {{ fn.x_callstart }} {{ fn.name }}({{ fn.parameters | join(', ', attribute='x_callname') }} {{ fn.x_callend }});
          {% for stmt in fn.x_lambda_post %}
          {{ stmt }};
          {% endfor %}
          {{ fn.x_wrap_return }}
        }
{%- endif %}
{%- endmacro -%}

{%- macro genmethod(cls, fn) %}
  {% if fn.constructor %}
    .def(py::init<{{ fn.parameters | join(', ', attribute='x_type_full') }}>(){% if fn.x_in_params %}, {{ fn.x_in_params | join(', ', attribute='x_pyarg') }}{% endif %}, release_gil())
  {% else %}
    .{{ fndef(fn) }}("{{ fn.x_name }}",{{ ' ' }}
      {%- if fn.data.overloads is defined and fn.data.overloads -%}
        py::overload_cast<{{ fn.x_in_params | join(', ', attribute='x_type_full')}}>(
      {%- endif -%}
	     {{ fnptr(cls, fn) }}
      {%- if fn.data.overloads is defined and fn.data.overloads -%}
        {% if fn.const %}, py::const_{% endif -%}
        )
      {%- endif -%}
		 {% if fn.x_in_params %}, {{ fn.x_in_params | join(', ', attribute='x_pyarg') }}{% endif %}
     {%- if not fn.data.no_release_gil -%}
      , release_gil()
     {%- endif -%}
     {%- if fn.x_doc %},
       {% for dq in fn.x_doc_quoted %}
          {{ dq }}{% if loop.nextitem is defined %}{{ '\n' }}{% endif %}
       {%- endfor -%}
     {%- endif -%})
  {% endif %}
{% endmacro -%}

{%- macro genprop(cls, prop) %}
    {% if prop.array_size is defined %}
    .def_property_readonly("{{ prop.name }}", []({{ prop.namespace}}{{ cls.name }}& inst) {
        return py::memoryview(py::buffer_info(
          &inst.{{ prop.name }}, sizeof({{ prop.type }}),
          py::format_descriptor<{{ prop.type }}>::format(),
          1, {{ "{" }}{{ prop.array_size }}{{ "}" }}, {sizeof({{ prop.type }})}
        ));
    })
    {% elif prop.array %}
    .def_property("{{ prop.name }}",
      [](const {{ prop.namespace}}{{ cls.name }}& inst) { return inst.{{ prop.name}}; },
      []({{ prop.namespace}}{{ cls.name }}& inst, const {{ prop.type }} v) {inst.{{ prop.name}} = v; })
    {% else %}
    .def_
      {%- if prop.constant or prop.constexpr -%}
        readonly
      {%- else -%}
        readwrite
      {%- endif -%}
      {%- if prop.static %}_static{% endif -%}
      ("{{ prop.name }}", &{{ prop.namespace }}{{ cls.name }}::{{ prop.name}})
    {% endif %}
{% endmacro -%}

{%- macro unnamed_enum(x, enums) %}
{% for enum in enums %}
{% if 'name' not in enum %}
{% for val in enum['values'] %}
{{ x }}.attr("{{ val.name }}") = (int){{ enum.x_namespace }}{{ val.name }};
{% endfor %}
{% endif %}
{% endfor %}
{% endmacro -%}

// This file is autogenerated. DO NOT EDIT
#include <robotpy_build.h>

{% for header in headers %}
#include <{{ header.rel_fname }}>
{% endfor %}

{% for header in headers %}
{% for using in header.using.values() %}
using {{ using.raw_type }};
{% endfor %}
{% endfor %}

{% for header in headers %}
{% for cls in header.classes if not cls.data.ignore %}
#include <rpygen/{{ cls.x_qualname_ }}.hpp>
{% endfor %}
{% endfor %}

{% for inc in data.extra_includes %}
#include "{{ inc }}"
{% endfor %}

void init_{{ mod_fn }}(py::module &m) {
{% for header in headers %}
{% for cls in header.classes if not cls.data.ignore %}
  py::class_<{{ cls.x_qualname }}, rpygen::Py{{ cls.x_qualname_ }}<{{ cls.x_qualname }}>{{ genbase(cls) }}> {{ cls.name.lower() }}(m, "{{ cls.name }}");
  {{ cls.name.lower() }}
  {# default constructor if not defined #}
  {% if not cls.x_has_constructor %}
    .def(py::init<>())
  {% endif %}
  {% for fn in cls.methods.public if not fn.data.ignore and 'forward_declare' not in fn %}
  {{ genmethod(cls, fn) }}
  {%- endfor %}
  {% for prop in cls.properties.public %}
  {{ genprop(cls, prop) }}
  {%- endfor %}
  {% for prop in cls.properties.protected %}
  {{ genprop(cls, prop) }}
  {%- endfor %}
  ;
  {{ unnamed_enum(cls.name.lower(), cls.enums.public) }}
{% endfor %}
{% endfor %}
{% for header in headers %}
{% for cls in header.classes if 'has_fwd_declare' in cls %}
  {{ cls.name.lower() }}
  {% for fn in cls.methods.public if 'forward_declare' in fn %}
  {{ genmethod(cls, fn) }}
  {%- endfor %}
  ;
  {{ unnamed_enum(cls.name.lower(), cls.enums.public) }}
{% endfor %}


{% if header.functions %}
{% for fn in header.functions if not fn.data.ignore %}
  {% if loop.first %}m{% endif %}
  {{ genmethod(None, fn) }}
{%- endfor %};
{% endif %}
{% endfor %}

  {% include "gen_enum_pybind11.cpp.j2" %}
}
