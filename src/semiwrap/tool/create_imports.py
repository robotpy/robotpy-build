import inspect
import posixpath
import subprocess
import typing
import types


class ImportCreator:
    @classmethod
    def add_subparser(cls, parent_parser, subparsers):
        parser = subparsers.add_parser(
            "create-imports",
            help="Generate suitable imports for a module",
            parents=[parent_parser],
        )
        parser.add_argument("base", help="Ex: wpiutil")
        parser.add_argument("compiled", nargs="?", help="Ex: wpiutil._impl.wpiutil")
        parser.add_argument(
            "--write", "-w", action="store_true", help="Modify existing __init__.py"
        )
        return parser

    def _rel(self, base: str, compiled: str) -> str:
        base = posixpath.join(*base.split("."))
        compiled = posixpath.join(*compiled.split("."))
        elems = posixpath.relpath(compiled, base).split("/")
        elems = ["" if e == ".." else e for e in elems]
        return f".{'.'.join(elems)}"

    def run(self, args):
        self.create(args.base, args.compiled, args.write)

    def create(self, base: str, compiled: typing.Optional[str], write: bool):
        # Runtime Dependency Check
        try:
            import black
        except:
            print("Error, The following module is required to run this tool: black")
            exit(1)

        if not compiled:
            compiled = f"{base}._{base.split('.')[-1]}"

        # TODO: could probably generate this from parsed code, but seems hard
        ctx = {}
        exec(f"from {compiled} import *", {}, ctx)
        for k in list(ctx.keys()):
            if isinstance(ctx[k], types.ModuleType):
                del ctx[k]

        relimport = self._rel(base, compiled)

        stmt_compiled = "" if not compiled else f" {compiled}"
        begin_stmt = f"# autogenerated by 'robotpy-build create-imports {base}"

        stmt = inspect.cleandoc(
            f"""

            {begin_stmt}{stmt_compiled}'
            from {relimport} import {','.join(sorted(ctx.keys()))}
            __all__ = ["{'", "'.join(sorted(ctx.keys()))}"]
        
        """
        )

        content = subprocess.check_output(
            ["black", "-", "-q"], input=stmt.encode("utf-8")
        ).decode("utf-8")

        if write:
            fctx = {}
            exec(f"from {base} import __file__", {}, fctx)
            fname = fctx["__file__"]

            with open(fname) as fp:
                fcontent = orig_content = fp.read()

            # Find the beginning statement
            idx = startidx = fcontent.find(begin_stmt)
            if startidx != -1:
                for to_find in ("from", "__all__", "[", "]", "\n"):
                    idx = fcontent.find(to_find, idx)
                    if idx == -1:
                        startidx = -1
                        break

            if startidx == -1:
                # If not present, just append and let the user figure it out
                fcontent = fcontent + "\n" + content
            else:
                fcontent = fcontent[:startidx] + content + fcontent[idx + 1 :]

            if fcontent != orig_content:
                with open(fname, "w") as fp:
                    fp.write(fcontent)
                print("MOD", base)
            else:
                print("OK", base)

        else:
            print(content)
